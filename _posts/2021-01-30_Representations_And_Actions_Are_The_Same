As with the motivation for defining a monoid object, I will formulate the definition of a left-module for a classical monoid in terms of diagrams, and then just replace \\(\times\\) with \\(\otimes\\) and call it a day. Thus, let \\((M,\mu,\iota)\\) be a monoid in the classical sense i.e. a monoid object in \\(\textbf{Set}\\). Then a left \\(M\\)-module is classically a set with a monoid homomorphism \\(\phi: M\to\text{End}\_{\textbf{Set}}(A)\\). In particular, element-wise one has

\begin{align\*}
    \phi(xy)(a) & = \phi(x)(\phi(y)(a))\newline
    \phi(1)(a) & = a
\end{align\*}

for all \\(x,y\in M\\) and \\(a\in A\\). The rigorous reader might have an issue with me using the term "module" or "representation," and instead might say this is a "monoid-action." To them I say, actions and representations are essentialy the same thing, and in fact the notion of module object is precisely the tool in unifying these concepts.

Now, the above equalities are equivalent to the following diagrams being commutative

![](/images/module diagrams.PNG)

where \\(\lambda\_{A}\\) is the left unitor as before, and where \\(\Phi: (m,a)\mapsto \phi(m)(a)\\). A subtle point is that \\(M\\) and \\(A\\) are objects of the same category! Indeed, \\((M,\mu,\iota)\\) is a monoid object over \\(\textbf{Set}\\), and \\(A\\) was assumed to simply be a set as well. Thus in the categorification, we will define module objects in the same category as that of the corresponding monoid object. In particular, if \\((M,\mu,\iota)\\) is a monoid object in a monoidal category \\((\mathcal{C},\otimes,\mathbb{1},\alpha,\lambda,\rho)\\), then \\((A,\Phi)\\) is a module object for \\((M,\mu,\iota)\\) if the following diagrams commute

![](/images/module object for a monoid diagrams.PNG)

And as we did with monoid objects, one can similarly define the dual notion of comodule objects, and consider the corresponding category of these respective objects with their notion of morphisms. For the latter, the notion of morphism of module objects \\((A,\Phi), (B,\Psi)\\) for a common monoid object \\((M,\mu,\iota)\\) is precisely a morphism \\(f:A\to B\\) such that the following diagram commutes

![](/images/morphisms of modules.PNG)

Upon doing so, one finds that the module objects in the above examples of monoid objects are the classical definition of modules e.g. a module object for a monoid object in \\(R\\)-\\(\textbf{mod}\\) is the usual notion of module for an \\(R\\)-algebra \\(A\\).  

In conclusion, categorification is awesome. Seemingly different objects that are defined and motivated by different circumstances are in a sense categorically the same. Whether it is a ring, an algebra over a field or a ring, or even a monad; these objects have the same categorical structure. Moreover, each of these are typically studied by looking at their notion of modules, but even these are also the same structure categorically. However, I am not saying that the categories for which these monoid objects exist are themselves necessarily the same or similar, beyond being monoidal. For instance, the categories \\(\textbf{Mon}\\) and \\(\textbf{Set}\\) are not \\(\textbf{Ab}\\)-enriched while \\(R\\)-\\(\textbf{mod}\\) is an abelian category.

While I am an advocate of generalizations, they certainly have their shortcomings. For instance, I highly doubt the factorization of finitely generated modules over a PID can be obtained through the lens of these categorical considerations! It would definitely be cool to see what such a categorical statement would be.









